<?xml version="1.0" encoding="UTF-8"?>
<!--
  TEACHING-MANUAL.xml - 知识结构与教学方法手册
  
  结构设计：按逻辑层次组织
  - 核心目标 → 知识分类（基础）→ 验证问题（应用）→ 教案编写（执行）→ 经验教训（改进）
  
  版本：4.0 (2026-01-08)
-->

<TeachingManual>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                           核心目标                                        ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <CoreGoal>
    <Mission>指导如何组织和讲解不同类型的知识，确保教案结构清晰、内容完整</Mission>
    <SuccessCriteria>
      <criterion>教案只包含组织指导，不包含具体内容</criterion>
      <criterion>每个知识类型的核心字段完整</criterion>
      <criterion>机制类知识形成完整闭环</criterion>
      <criterion>验证问题避免并列答案</criterion>
    </SuccessCriteria>
    <Usage>创建教案时加载此手册</Usage>
  </CoreGoal>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    第一层：知识分类体系（基础）                             ║
       ║  目的：根据知识的核心目的分类，不同类型有不同的结构要求                       ║
       ║  关系：这是后续教学方法的基础                                              ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <KnowledgeClassification>
    <Purpose>根据知识的核心目的分类，每种类型有特定的结构要求和闭环检查</Purpose>
    <HowToJudge>问自己：这个知识的核心目的是什么？</HowToJudge>
    
    <Types>
      <!-- 类型1：机制/协议类（最常用） -->
      <Type id="1" name="机制/协议类" frequency="高">
        <when_to_use>讲解具体的技术机制或协议</when_to_use>
        <core_fields>
          <field name="定义" required="true">是什么 + 核心特点</field>
          <field name="核心机制" required="true" must_close_loop="true">
            <subfield>输入：什么触发这个机制？</subfield>
            <subfield>处理：具体步骤是什么？</subfield>
            <subfield>输出：产生什么效果？</subfield>
            <subfield>异常：边界情况如何处理？</subfield>
          </field>
        </core_fields>
        <extended_fields>重要性、关键参数、代价与缓解、适用边界</extended_fields>
        <check>机制是否有完整的输入→处理→输出→异常？</check>
      </Type>
      
      <!-- 类型2：对比分析类 -->
      <Type id="2" name="对比分析类" frequency="高">
        <when_to_use>对比两个或多个方案的异同</when_to_use>
        <core_fields>
          <field name="方案描述" required="true" note="每个方案使用统一框架">
            <subfield>核心机制：如何工作</subfield>
            <subfield>效果：解决什么问题</subfield>
            <subfield>代价：牺牲什么</subfield>
          </field>
          <field name="对比维度" required="true">各方案在每个维度的表现</field>
          <field name="选择标准" required="true">条件 → 选择哪个 → 理由</field>
        </core_fields>
        <check>每个方案是否用统一框架描述？选择标准是否可操作？</check>
      </Type>
      
      <!-- 类型3：技术方案类 -->
      <Type id="3" name="技术方案类" frequency="中">
        <when_to_use>讲解多个方案如何解决同一问题</when_to_use>
        <core_fields>
          <field name="问题描述" required="true">要解决什么问题</field>
          <field name="分类维度" required="true">方案的切入口/设计思路</field>
          <field name="每个方案" required="true">
            <subfield>机制协同关系：多个机制如何配合</subfield>
            <subfield>每个机制的链条：机制→效果→代价→缓解→场景</subfield>
          </field>
        </core_fields>
        <check>每个机制是否有完整的效果→代价→缓解链条？</check>
      </Type>
      
      <!-- 类型4-6：中频类型 -->
      <Type id="4" name="概念定义类" frequency="中">
        <when_to_use>引入新概念/术语时</when_to_use>
        <core_fields>定义 + 核心特征 + 具体示例</core_fields>
        <check>定义是否精确？与相关概念的边界是否清晰？</check>
      </Type>
      
      <Type id="5" name="性能指标类" frequency="中">
        <when_to_use>讲解可量化的系统指标</when_to_use>
        <core_fields>定义（单位、计算方式）+ 影响因素（如何影响）+ 数据参考（标注来源）</core_fields>
        <check>影响因素是否说明了"如何影响"而不只是"是什么"？</check>
      </Type>
      
      <Type id="6" name="应用边界类" frequency="低">
        <when_to_use>讲解某技术的适用范围和限制</when_to_use>
        <core_fields>核心能力 + 硬边界（技术限制）+ 软边界（权衡选择）</core_fields>
        <check>硬边界和软边界是否区分清楚？</check>
      </Type>
      
      <!-- 类型7-9：低频类型 -->
      <Type id="7" name="问题诊断类" frequency="低">
        <when_to_use>分析问题的根因和解决思路</when_to_use>
        <core_fields>问题现象 → 可能原因（按可能性排序）→ 解决方案</core_fields>
      </Type>
      
      <Type id="8" name="演进/历史类" frequency="低">
        <when_to_use>讲解技术的演进过程</when_to_use>
        <core_fields>演进过程（阶段N：方案→问题→改进）→ 当前最佳实践</core_fields>
        <check>每个阶段是否说明了"发现的问题"？</check>
      </Type>
      
      <Type id="9" name="架构决策类" frequency="低">
        <when_to_use>讲解架构设计中的关键决策点</when_to_use>
        <core_fields>决策点 → 可选方案 → 评估维度 → 推荐选择（条件→方案→理由）</core_fields>
      </Type>
    </Types>
  </KnowledgeClassification>


  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    第二层：验证问题设计（应用）                              ║
       ║  目的：指导如何设计能检验真正理解的验证问题                                   ║
       ║  关系：基于知识类型（第一层）设计对应的验证问题                               ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <VerificationQuestionGuide>
    <Purpose>设计能检验真正理解的问题，而非死记硬背</Purpose>
    <Depends>知识类型决定了验证问题的方向</Depends>
    
    <!-- 核心原则：避免并列答案 -->
    <CorePrinciple>
      <rule>问题的答案不应是并列列举</rule>
      <why>并列答案无法检验学生对逻辑关系的理解</why>
      <bad_example>三种安全机制分别是什么？→ 会得到"A是X，B是Y，C是Z"</bad_example>
      <good_example>为什么端到端加密会增加调试难度？→ 会得到因果链</good_example>
    </CorePrinciple>
    
    <!-- 四层验证问题（L1-L4） -->
    <Levels>
      <Level code="L1" name="事实性" count="2">
        <purpose>检验基本概念的掌握</purpose>
        <patterns>X的定义是什么？| 影响X的因素有哪些？（需追问关系）| X的核心特征是什么？</patterns>
        <avoid>不要问"分别是什么"</avoid>
      </Level>
      
      <Level code="L2" name="因果性" count="2">
        <purpose>检验对原理的理解</purpose>
        <patterns>为什么X会导致Y？| X的根本原因是什么？| 如果没有X，会发生什么？</patterns>
        <requirement>答案应该是因果链，不是并列</requirement>
      </Level>
      
      <Level code="L3" name="权衡性" count="1">
        <purpose>检验对权衡的理解</purpose>
        <patterns>选择X牺牲了什么？获得了什么？| 在什么场景下选择X而不是Y？为什么？</patterns>
        <requirement>答案应该是权衡分析，不是简单对比</requirement>
      </Level>
      
      <Level code="L4" name="应用性" count="1">
        <purpose>检验能否将知识迁移到新场景</purpose>
        <patterns>
          <pattern type="场景决策">给定场景X，你会选择什么方案？为什么？</pattern>
          <pattern type="问题诊断">系统出现X现象，可能是什么原因？你会如何排查？</pattern>
          <pattern type="方案设计">如果要实现X目标，你会如何设计？</pattern>
          <pattern type="边界判断">这个方案在什么情况下会失效？</pattern>
        </patterns>
        <requirement>答案应该是决策过程，包含：分析→选择→理由→风险</requirement>
        <note>L4问题是可选的，用于核心知识点或学生希望深入时</note>
      </Level>
    </Levels>
    
    <!-- 按知识类型的验证方向 -->
    <ByKnowledgeType>
      <Type name="机制/协议类">
        <L1>机制的触发条件/输入是什么？</L1>
        <L2>为什么这个机制能解决X问题？</L2>
        <L3>这个机制的代价是什么？如何缓解？</L3>
        <L4>给定场景X（具体约束），你会选择这个机制吗？为什么？</L4>
      </Type>
      <Type name="对比分析类">
        <L1>A和B的核心差异是什么？</L1>
        <L2>为什么A在X场景下比B更合适？</L2>
        <L3>选择A牺牲了什么？什么时候这个牺牲不可接受？</L3>
        <L4>给定场景X（多个约束条件），你会选择哪个方案？决策过程是什么？</L4>
      </Type>
      <Type name="性能指标类">
        <L1>X指标的定义和计算方式是什么？</L1>
        <L2>为什么Y因素会影响X指标？</L2>
        <L3>提高X指标需要牺牲什么？</L3>
        <L4>系统X指标不达标，你会如何排查和优化？</L4>
      </Type>
    </ByKnowledgeType>
  </VerificationQuestionGuide>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    第2.5层：前置知识确认（教学前必做）                        ║
       ║  目的：确保学生具备理解新知识的基础，明确术语边界                              ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <PrerequisiteCheck>
    <Purpose>教授新知识前，确认学生具备前置知识，并明确术语定义</Purpose>
    <Why>
      <reason>前置知识不足会导致学生无法理解新内容</reason>
      <reason>术语边界不清会导致概念混淆</reason>
    </Why>
    
    <!-- 前置知识确认流程 -->
    <Workflow>
      <step order="1" name="识别前置知识">
        <action>分析本次教学内容依赖哪些前置概念</action>
        <question>理解这个知识点需要先知道什么？</question>
        <output>前置知识列表</output>
      </step>
      
      <step order="2" name="检查学生知识库">
        <action>检查 learning-state.json 和 reusable-knowledge.json</action>
        <question>学生是否已经学过这些前置知识？</question>
        <if_learned>跳到步骤4</if_learned>
        <if_not_learned>继续步骤3</if_not_learned>
      </step>
      
      <step order="3" name="补充前置知识">
        <action>简要介绍缺失的前置知识，或询问学生是否需要先学习</action>
        <format><![CDATA[
在学习「X」之前，需要先了解「Y」的概念。
你是否已经了解Y？
- 如果了解：请简要说明你的理解
- 如果不了解：我先简要介绍一下
        ]]></format>
      </step>
      
      <step order="4" name="明确术语边界">
        <action>定义本次教学中使用的关键术语</action>
        <why>同一术语在不同上下文可能有不同含义</why>
        <format><![CDATA[
**术语约定**：
在本次教学中：
- 「X」指的是：[精确定义]，不包括[排除的含义]
- 「Y」指的是：[精确定义]
        ]]></format>
        <example><![CDATA[
**术语约定**：
- 「一致性」指的是：数据副本之间的一致性（CAP中的C），不是事务ACID中的一致性
- 「可用性」指的是：系统能响应请求（CAP中的A），不是SLA中的可用性百分比
        ]]></example>
      </step>
    </Workflow>
    
    <!-- 常见需要明确边界的术语 -->
    <CommonAmbiguousTerms>
      <term name="一致性">CAP一致性 vs ACID一致性 vs 最终一致性</term>
      <term name="可用性">CAP可用性 vs SLA可用性 vs 高可用</term>
      <term name="事务">数据库事务 vs 分布式事务 vs 业务事务</term>
      <term name="同步">同步调用 vs 数据同步 vs 时钟同步</term>
      <term name="分区">网络分区 vs 数据分区 vs 分区容错</term>
      <term name="消息">消息队列的消息 vs 事件 vs 命令</term>
    </CommonAmbiguousTerms>
    
    <!-- 教案中的前置知识字段 -->
    <TeachingPlanField>
      <field name="prerequisites" required="true">
        <subfield>required_concepts：必须已学的概念列表</subfield>
        <subfield>terminology：需要明确边界的术语及其定义</subfield>
      </field>
    </TeachingPlanField>
  </PrerequisiteCheck>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    第三层：教案编写指南（执行）                              ║
       ║  目的：指导如何编写高质量的教案                                             ║
       ║  关系：教案结构基于知识类型（第一层），验证问题参考第二层                       ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <TeachingPlanGuide>
    <Purpose>指导教案编写，确保教案只包含组织指导而非具体内容</Purpose>
    <Depends>知识类型 → 核心字段 → 教案结构</Depends>
    
    <!-- 教案的核心原则 -->
    <CorePrinciple>
      <rule>教案 = 结构框架，不是内容填充</rule>
      <why>教案指导"如何组织教学"，具体内容在教学时生成</why>
      <forbidden>教案中出现具体技术名称、定义文本、示例数据</forbidden>
    </CorePrinciple>
    
    <!-- ═══════════════ 逻辑关系详解（核心！） ═══════════════ -->
    <LogicalRelationshipGuide>
      <Purpose>不能只说"递进"，必须说明递进的维度和排序依据</Purpose>
      
      <!-- 递进关系：最常用，也最容易出错 -->
      <Relation name="递进">
        <definition>后一个建立在前一个的基础上，或解决前一个的局限</definition>
        
        <Dimensions comment="递进可以沿着不同维度进行">
          <dimension id="PRO-1" name="能力递进">
            <description>从基础能力到高级能力</description>
            <ordering>简单 → 复杂</ordering>
            <example>读操作 → 写操作 → 事务操作</example>
            <chain>前一个是后一个的前提条件</chain>
          </dimension>
          
          <dimension id="PRO-2" name="范围递进">
            <description>从局部到全局，从单点到分布式</description>
            <ordering>小范围 → 大范围</ordering>
            <example>单机缓存 → 分布式缓存 → 多级缓存</example>
            <chain>前一个的局限（范围不够）→ 后一个如何扩展</chain>
          </dimension>
          
          <dimension id="PRO-3" name="信任边界递进">
            <description>从信任到不信任</description>
            <ordering>信任多 → 信任少</ordering>
            <example>传输层加密（信任中间件）→ 端到端加密（不信任中间件）</example>
            <chain>前一个的假设（信任X）→ 后一个去掉这个假设</chain>
          </dimension>
          
          <dimension id="PRO-4" name="抽象层次递进">
            <description>从具体到抽象，或从抽象到具体</description>
            <ordering>具体 → 抽象 或 抽象 → 具体</ordering>
            <example>具体实现 → 设计模式 → 架构原则</example>
            <chain>前一个是后一个的实例/具体化</chain>
          </dimension>
          
          <dimension id="PRO-5" name="保障强度递进">
            <description>从弱保障到强保障</description>
            <ordering>弱 → 强</ordering>
            <example>最终一致性 → 因果一致性 → 强一致性</example>
            <chain>前一个的不足（保障不够）→ 后一个如何加强 + 代价</chain>
          </dimension>
          
          <dimension id="PRO-6" name="解耦程度递进">
            <description>从紧耦合到松耦合</description>
            <ordering>耦合度高 → 耦合度低</ordering>
            <example>同步调用 → 异步消息 → 事件驱动</example>
            <chain>前一个的耦合点 → 后一个如何解除 + 代价</chain>
          </dimension>
        </Dimensions>
        
        <RequiredInStructure>
          <item>递进维度：沿着什么维度递进？</item>
          <item>排序依据：为什么A在B前面？</item>
          <item>链条要求：前一个的局限 → 后一个如何解决</item>
        </RequiredInStructure>
        
        <Example type="correct"><![CDATA[
"逻辑关系": "递进",
"递进维度": "信任边界（PRO-3）",
"排序依据": "从信任中间件到不信任中间件",
"链条要求": "方案A假设中间件可信 → 方案B去掉这个假设，代价是X"]]></Example>
        
        <Example type="wrong"><![CDATA[
"逻辑关系": "递进"
（问题：没有说明递进维度和排序依据）]]></Example>
      </Relation>
      
      <!-- 因果关系 -->
      <Relation name="因果">
        <definition>A导致B，或A是B的原因</definition>
        
        <Dimensions>
          <dimension id="CAU-1" name="问题-原因">
            <description>从现象追溯到根因</description>
            <ordering>现象 → 直接原因 → 根本原因</ordering>
            <chain>为什么会出现X？→ 因为Y → 为什么Y？→ 因为Z</chain>
          </dimension>
          
          <dimension id="CAU-2" name="原因-结果">
            <description>从原因推导到结果</description>
            <ordering>原因 → 直接结果 → 间接影响</ordering>
            <chain>X发生 → 导致Y → 进而影响Z</chain>
          </dimension>
          
          <dimension id="CAU-3" name="设计-效果">
            <description>设计决策导致的效果</description>
            <ordering>设计选择 → 直接效果 → 副作用</ordering>
            <chain>选择X设计 → 获得Y效果 → 但带来Z代价</chain>
          </dimension>
        </Dimensions>
        
        <RequiredInStructure>
          <item>因果方向：是问题→原因还是原因→结果？</item>
          <item>因果链深度：追溯到哪一层？</item>
        </RequiredInStructure>
      </Relation>
      
      <!-- 对比关系 -->
      <Relation name="对比">
        <definition>A和B在某些维度上的异同</definition>
        
        <Dimensions>
          <dimension id="CMP-1" name="方案对比">
            <description>不同方案解决同一问题的差异</description>
            <framework>每个方案：机制 + 效果 + 代价 + 适用场景</framework>
          </dimension>
          
          <dimension id="CMP-2" name="概念对比">
            <description>相似概念的区别</description>
            <framework>定义差异 + 适用范围差异 + 常见混淆点</framework>
          </dimension>
        </Dimensions>
        
        <RequiredInStructure>
          <item>对比维度：从哪些维度对比？</item>
          <item>统一框架：每个对象用相同的结构描述</item>
          <item>选择标准：什么条件下选A，什么条件下选B</item>
        </RequiredInStructure>
      </Relation>
      
      <!-- 分类关系 -->
      <Relation name="分类">
        <definition>按某个维度将事物划分为不同类别</definition>
        
        <Dimensions>
          <dimension id="CLS-1" name="按功能分类">按解决的问题类型划分</dimension>
          <dimension id="CLS-2" name="按实现方式分类">按技术实现方式划分</dimension>
          <dimension id="CLS-3" name="按适用场景分类">按使用场景划分</dimension>
          <dimension id="CLS-4" name="按复杂度分类">按实现或使用复杂度划分</dimension>
        </Dimensions>
        
        <RequiredInStructure>
          <item>分类维度：按什么标准分类？</item>
          <item>分类依据：为什么用这个维度？</item>
          <item>类别排序：类别之间有没有顺序？如果有，依据是什么？</item>
          <item>MECE检查：是否互斥且完整？</item>
        </RequiredInStructure>
      </Relation>
      
      <!-- 时序关系 -->
      <Relation name="时序">
        <definition>按时间或执行顺序组织</definition>
        
        <RequiredInStructure>
          <item>时序类型：是执行步骤还是生命周期阶段？</item>
          <item>步骤依赖：后一步是否依赖前一步的输出？</item>
          <item>可选步骤：哪些步骤是可选的？</item>
        </RequiredInStructure>
      </Relation>
      
      <!-- 演进关系 -->
      <Relation name="演进">
        <definition>技术或方案随时间的发展变化</definition>
        
        <RequiredInStructure>
          <item>演进驱动力：是什么推动了演进？（问题、需求、技术进步）</item>
          <item>每个阶段：方案 → 解决的问题 → 新产生的问题 → 下一阶段如何改进</item>
          <item>当前最佳实践：演进到现在的推荐方案</item>
        </RequiredInStructure>
      </Relation>
    </LogicalRelationshipGuide>
    
    <!-- structure字段设计 -->
    <StructureFieldDesign>
      <RequiredElements>
        <element>逻辑关系类型：递进/演进/因果/对比/时序/分类</element>
        <element>具体维度：参考 LogicalRelationshipGuide 中的维度编号</element>
        <element>排序依据：为什么按这个顺序？</element>
        <element>子结构要求：每个子项需要包含哪些字段？</element>
        <element>链条要求：前后项之间如何衔接？</element>
      </RequiredElements>
      
      <Example type="correct"><![CDATA[
"structure": {
  "逻辑关系": "递进",
  "递进维度": "PRO-3（信任边界递进）",
  "排序依据": "从信任中间件到不信任中间件",
  "子结构要求": ["保护什么", "解决什么威胁", "代价", "缓解", "场景"],
  "链条要求": "方案A假设中间件可信，局限是X → 方案B去掉这个假设，代价是Y"
}]]></Example>
      
      <Example type="wrong"><![CDATA[
"structure": { "逻辑关系": "递进" }
（问题：没有说明递进维度、排序依据、链条要求）]]></Example>
    </StructureFieldDesign>
    
    <!-- 教案JSON结构 -->
    <TeachingPlanStructure>
      <field name="hook_question" required="true">钩子问题</field>
      <field name="supporting_knowledge" required="true">支撑知识名称</field>
      <field name="knowledge_type" required="true">知识类型（参考第一层）</field>
      <field name="prerequisites" required="true">
        <subfield name="required_concepts">必须已学的概念列表</subfield>
        <subfield name="terminology">需要明确边界的术语及其定义</subfield>
      </field>
      <field name="core_fields" required="true">该类型的核心字段</field>
      <field name="structure" required="true">组织指导（含逻辑关系、维度、排序依据、链条要求）</field>
      <field name="verification_questions" required="true">L1-L4验证问题方向（L4可选）</field>
      <field name="bridging" required="true">如何支撑钩子问题</field>
      <field name="transition" required="true">如何过渡到下一个知识</field>
      <field name="risk_points" optional="true">容易违规的地方</field>
    </TeachingPlanStructure>
  </TeachingPlanGuide>


  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    第四层：经验教训（改进）                                  ║
       ║  目的：记录常见问题和解决方案，避免重复犯错                                   ║
       ║  关系：这是对前三层执行过程中发现问题的总结                                   ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <LessonsLearned>
    <Purpose>记录常见问题，避免重复犯错</Purpose>
    
    <Category name="知识类型判断">
      <Lesson id="KT-1">
        <mistake>从"内容包含什么"角度判断类型</mistake>
        <correct>从"核心目的是什么"角度判断</correct>
      </Lesson>
      <Lesson id="KT-2">
        <mistake>混淆"对比分析类"和"技术方案类"</mistake>
        <correct>对比分析：重点是异同；技术方案：重点是如何解决问题</correct>
      </Lesson>
    </Category>
    
    <Category name="逻辑关系选择">
      <Lesson id="LR-1">
        <mistake>只说"递进"，不说明递进维度</mistake>
        <correct>必须指明递进维度（PRO-1到PRO-6）和排序依据</correct>
        <example>错误："递进关系" → 正确："递进（PRO-3信任边界），从信任中间件到不信任中间件"</example>
      </Lesson>
      <Lesson id="LR-2">
        <mistake>递进关系没有链条要求</mistake>
        <correct>必须说明"前一个的局限 → 后一个如何解决"</correct>
      </Lesson>
      <Lesson id="LR-3">
        <mistake>分类没有说明分类维度</mistake>
        <correct>必须说明按什么标准分类，以及类别之间是否有顺序</correct>
      </Lesson>
      <Lesson id="LR-4">
        <mistake>对比没有统一框架</mistake>
        <correct>每个对比对象必须用相同的结构描述</correct>
      </Lesson>
    </Category>
    
    <Category name="教案编写">
      <Lesson id="TP-1">
        <mistake>structure字段包含具体技术名称</mistake>
        <correct>structure只包含组织指导（逻辑关系、排序依据、子结构要求）</correct>
      </Lesson>
      <Lesson id="TP-2">
        <mistake>验证问题会导致并列答案</mistake>
        <correct>预测答案形式，避免"分别是什么"类问题</correct>
      </Lesson>
      <Lesson id="TP-3">
        <mistake>机制类知识没有闭环</mistake>
        <correct>必须包含：输入→处理→输出→异常</correct>
      </Lesson>
    </Category>
    
    <Category name="验证问题">
      <Lesson id="VQ-1">
        <mistake>问"X有哪些特点/类型/方式"</mistake>
        <correct>问"为什么X有这个特点"或"X的核心特点是什么"</correct>
      </Lesson>
      <Lesson id="VQ-2">
        <mistake>L2问题没有预埋线索</mistake>
        <correct>在教学中预埋因果链的关键节点</correct>
      </Lesson>
    </Category>
  </LessonsLearned>

  <!-- 更新记录 -->
  <UpdateHistory>
    <Update date="2026-01-07" version="3.0">从Markdown转换为XML格式，重组为9种知识类型</Update>
    <Update date="2026-01-08" version="4.0">按逻辑层次重构：知识分类→验证问题→教案编写→经验教训</Update>
    <Update date="2026-01-08" version="4.1">增加逻辑关系详解：递进6种维度、因果3种维度、对比/分类/时序/演进的具体要求</Update>
    <Update date="2026-01-08" version="4.2">增加L4应用性问题；增加前置知识确认和术语边界定义环节</Update>
  </UpdateHistory>

</TeachingManual>
