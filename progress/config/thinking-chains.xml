<?xml version="1.0" encoding="UTF-8"?>
<!--
  thinking-chains.xml - 思维链指南
  
  结构设计：目的驱动 + 显式思考 + 自检验证
  - 每步有 purpose（为什么）→ thinking（怎么想）→ self_check（验证）
  
  版本：4.0 (2026-01-08)
-->

<ThinkingChains>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                           核心目标                                        ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <CoreGoal>
    <Mission>提供教案编写和笔记编写的完整思维链路，确保高质量输出</Mission>
    <SuccessCriteria>
      <criterion>每一步都有明确的目的（why）</criterion>
      <criterion>每一步都显式输出思考过程</criterion>
      <criterion>每一步都有自检点</criterion>
      <criterion>最后有反向验证（发现潜在问题）</criterion>
    </SuccessCriteria>
    <OutputFormat><![CDATA[
**Step N: [步骤名称]**
目的：[为什么要做这一步]

<thinking>
[思考过程]
</thinking>

自检：
- ✓/✗ 检查项1
- ✓/✗ 检查项2
    ]]></OutputFormat>
  </CoreGoal>

  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    教案编写思维链（10步）                                   ║
       ║  流程：识别类型 → 识别前置知识 → 定义术语边界 → 确定字段 → 设计结构           ║
       ║       → 设计验证问题 → 设计桥接 → 识别风险 → 最终自检 → 反向验证             ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <TeachingPlanChain id="teaching-plan" name="教案编写思维链">
    
    <Step order="1" name="识别知识类型">
      <purpose>确定知识类型决定了后续的结构要求，错误的类型判断会导致整个教案结构不合适</purpose>
      <thinking><![CDATA[
问自己：这个知识的核心目的是什么？
- 讲解具体的技术机制？→ 机制/协议类
- 对比多个方案的异同？→ 对比分析类
- 讲解多个方案如何解决同一问题？→ 技术方案类
- 引入一个新概念？→ 概念定义类
- 讲解可量化的指标？→ 性能指标类
      ]]></thinking>
      <self_check>
        <check>□ 我是否从"核心目的"角度判断，而不是从"内容包含什么"角度？</check>
        <check>□ 我是否考虑了这个知识在钩子问题中的角色？</check>
      </self_check>
    </Step>

    <Step order="2" name="识别前置知识">
      <purpose>确保学生具备理解新知识的基础，前置知识不足会导致学生无法理解</purpose>
      <thinking><![CDATA[
问自己：理解这个知识点需要先知道什么？
1. 列出所有依赖的前置概念
2. 检查 learning-state.json：学生是否已学过？
3. 检查 reusable-knowledge.json：是否有可复用的维度？

如果前置知识不足：
- 简要介绍缺失的概念
- 或询问学生是否需要先学习
      ]]></thinking>
      <self_check>
        <check>□ 我是否列出了所有前置概念？</check>
        <check>□ 我是否检查了学生的知识库？</check>
        <check>□ 缺失的前置知识是否有补充计划？</check>
      </self_check>
    </Step>

    <Step order="3" name="定义术语边界">
      <purpose>同一术语在不同上下文可能有不同含义，明确边界避免概念混淆</purpose>
      <thinking><![CDATA[
问自己：本次教学中有哪些可能产生歧义的术语？

常见歧义术语：
- 一致性：CAP一致性 vs ACID一致性 vs 最终一致性
- 可用性：CAP可用性 vs SLA可用性
- 事务：数据库事务 vs 分布式事务
- 同步：同步调用 vs 数据同步 vs 时钟同步
- 分区：网络分区 vs 数据分区

对每个歧义术语：
- 明确本次使用的含义
- 明确排除的含义
      ]]></thinking>
      <self_check>
        <check>□ 我是否识别了所有可能产生歧义的术语？</check>
        <check>□ 每个术语是否有明确的定义和排除？</check>
      </self_check>
      <output_format><![CDATA[
**术语约定**：
- 「X」指的是：[精确定义]，不包括[排除的含义]
- 「Y」指的是：[精确定义]
      ]]></output_format>
    </Step>

    <Step order="4" name="确定核心字段">
      <purpose>核心字段是该类型知识必须回答的问题，遗漏会导致学生理解不完整</purpose>
      <thinking><![CDATA[
根据知识类型，参考 TEACHING-MANUAL.xml 确定核心字段。
机制类必须有闭环：输入→处理→输出→异常
对比类必须有统一框架：每个方案用相同维度描述
      ]]></thinking>
      <self_check>
        <check>□ 我是否列出了该类型的所有核心字段？</check>
        <check>□ 机制类是否包含完整闭环？</check>
        <check>□ 对比类是否使用统一框架？</check>
      </self_check>
    </Step>

    <Step order="5" name="设计structure字段">
      <purpose>structure指导"如何组织教学"而非"教什么内容"，逻辑关系必须具体到维度和排序依据</purpose>
      <thinking><![CDATA[
structure = 结构框架，不是内容填充。
核心原则：不能只说"递进"，必须说明递进的维度、排序依据、链条要求。

【第一步：选择逻辑关系类型】
问自己：这些知识点之间是什么关系？
- 递进：后一个建立在前一个基础上，或解决前一个的局限
- 因果：A导致B，或A是B的原因
- 对比：A和B在某些维度上的异同
- 分类：按某个维度将事物划分为不同类别
- 时序：按时间或执行顺序组织
- 演进：技术或方案随时间的发展变化

【第二步：根据关系类型，确定具体维度】

■ 如果是【递进】，选择具体维度：
  - PRO-1 能力递进：简单→复杂（前一个是后一个的前提条件）
  - PRO-2 范围递进：局部→全局（前一个的局限是范围不够）
  - PRO-3 信任边界递进：信任多→信任少（后一个去掉前一个的信任假设）
  - PRO-4 抽象层次递进：具体→抽象 或 抽象→具体
  - PRO-5 保障强度递进：弱→强（前一个保障不够，后一个加强+代价）
  - PRO-6 解耦程度递进：紧耦合→松耦合（后一个解除前一个的耦合点+代价）

■ 如果是【因果】，选择具体维度：
  - CAU-1 问题-原因：现象→直接原因→根本原因
  - CAU-2 原因-结果：原因→直接结果→间接影响
  - CAU-3 设计-效果：设计选择→直接效果→副作用

■ 如果是【对比】，确定：
  - 对比维度：从哪些维度对比？
  - 统一框架：每个对象用相同的结构描述（机制+效果+代价+场景）
  - 选择标准：什么条件下选A，什么条件下选B

■ 如果是【分类】，确定：
  - 分类维度：按什么标准分类？（功能/实现方式/适用场景/复杂度）
  - 分类依据：为什么用这个维度？
  - 类别排序：类别之间有没有顺序？依据是什么？
  - MECE检查：是否互斥且完整？

■ 如果是【时序】，确定：
  - 时序类型：是执行步骤还是生命周期阶段？
  - 步骤依赖：后一步是否依赖前一步的输出？
  - 可选步骤：哪些步骤是可选的？

■ 如果是【演进】，确定：
  - 演进驱动力：是什么推动了演进？（问题/需求/技术进步）
  - 每个阶段：方案→解决的问题→新产生的问题→下一阶段如何改进
  - 当前最佳实践：演进到现在的推荐方案

【第三步：确定排序依据】
问自己：为什么A在B前面？
- 必须有明确的、可解释的理由
- 禁止使用"按重要性""按优先级"等模糊词语而不说明标准

【第四步：确定链条要求】
问自己：前后项之间如何衔接？
- 递进：前一个的局限 → 后一个如何解决 + 代价
- 演进：前一个的问题 → 后一个如何改进
- 因果：A → 导致 → B

【第五步：确定子结构要求】
问自己：每个子项需要包含哪些字段？
- 例如：机制、效果、代价、缓解、场景

禁止在structure中出现具体技术名称或定义文本。
      ]]></thinking>
      <output_example><![CDATA[
正确示例：
"structure": {
  "逻辑关系": "递进",
  "递进维度": "PRO-3（信任边界递进）",
  "排序依据": "从信任中间件到不信任中间件",
  "链条要求": "方案A假设中间件可信，局限是X → 方案B去掉这个假设，代价是Y",
  "子结构要求": ["保护什么", "解决什么威胁", "代价", "缓解", "场景"]
}

错误示例：
"structure": { "逻辑关系": "递进" }
（问题：没有说明递进维度、排序依据、链条要求）
      ]]></output_example>
      <self_check>
        <check>□ structure是否只包含组织指导，不包含具体知识点名称？</check>
        <check>□ 逻辑关系是否指明了具体维度编号？</check>
        <check>□ 是否有明确的、可解释的排序依据？</check>
        <check>□ 是否有链条要求说明前后项如何衔接？</check>
        <check>□ 是否有子结构要求？</check>
        <check>□ 我是否使用了模糊词语（如"按重要性"）而没有说明标准？</check>
      </self_check>
    </Step>

    <Step order="6" name="设计验证问题">
      <purpose>验证问题检验学生是否真正理解而非死记硬背；避免并列答案</purpose>
      <thinking><![CDATA[
验证问题覆盖四个层次：
- L1（事实性）：定义、特征
- L2（因果性）：为什么X导致Y
- L3（权衡性）：场景选择、代价权衡
- L4（应用性，可选）：给定场景做决策、问题诊断、方案设计

L4问题类型：
- 场景决策：给定场景X，你会选择什么方案？为什么？
- 问题诊断：系统出现X现象，可能是什么原因？如何排查？
- 方案设计：如果要实现X目标，你会如何设计？
- 边界判断：这个方案在什么情况下会失效？

关键：预测答案形式，避免"分别是什么"类问题。
      ]]></thinking>
      <self_check>
        <check>□ L1-L3问题是否都有方向？</check>
        <check>□ 是否考虑了L4应用性问题（核心知识点）？</check>
        <check>□ 问题是否避免了"分别是什么"这样的表述？</check>
        <check>□ 我是否预测了学生的回答形式？</check>
        <check>□ L2-L4问题的线索是否需要在教学中预埋？</check>
      </self_check>
    </Step>

    <Step order="7" name="设计桥接和过渡">
      <purpose>桥接让学生理解"学这个有什么用"，过渡让知识点之间有连贯性</purpose>
      <thinking><![CDATA[
桥接：这个支撑知识如何帮助回答钩子问题？
过渡：如何连接到下一个支撑知识？逻辑关系是什么？
      ]]></thinking>
      <self_check>
        <check>□ 桥接是否说明了与钩子问题的关系？</check>
        <check>□ 过渡是否说明了与下一个知识的逻辑关系？</check>
      </self_check>
    </Step>

    <Step order="8" name="识别风险点">
      <purpose>预防胜于纠正，提前识别容易违规的地方</purpose>
      <thinking><![CDATA[
常见风险：
- 并列列举（没有说明逻辑关系）
- 递进关系没有指明维度
- 机制不闭环
- 权衡无缓解
- 概念未定义
- 术语边界不清
- 验证问题导致并列答案
      ]]></thinking>
      <self_check>
        <check>□ 我是否识别了这个教案特有的风险点？</check>
        <check>□ 每个风险点是否有预防措施？</check>
      </self_check>
    </Step>

    <Step order="9" name="最终自检">
      <purpose>最后一道防线，确保教案符合所有质量标准</purpose>
      <self_check>
        <check>□ 前置知识是否已识别并有补充计划？</check>
        <check>□ 歧义术语是否已定义边界？</check>
        <check>□ structure字段不包含具体技术名称或知识点</check>
        <check>□ 递进关系是否指明了具体维度和排序依据？</check>
        <check>□ 机制类内容有完整的闭环要求</check>
        <check>□ 递进/演进关系有链条要求</check>
        <check>□ 验证问题避免并列答案</check>
        <check>□ 核心知识点是否有L4应用性问题？</check>
      </self_check>
    </Step>

    <Step order="10" name="反向验证">
      <purpose>发现自己的盲点，从"可能出错"的角度审视输出</purpose>
      <thinking><![CDATA[
问自己：
1. 这个教案可能有什么问题？
2. 教师按这个教案教学时，可能在哪里卡住？
3. 学生可能在哪里产生误解？
4. 有没有遗漏的前置知识？
5. 术语边界是否足够清晰？
      ]]></thinking>
      <self_check>
        <check>□ 我是否诚实地审视了潜在问题？</check>
        <check>□ 发现的问题是否已在教案中补充说明？</check>
      </self_check>
    </Step>
  </TeachingPlanChain>


  <!-- ╔═══════════════════════════════════════════════════════════════════════════╗
       ║                    笔记编写思维链（7步）                                    ║
       ║  流程：确定范围 → 确定结构 → 融合信息 → 应用格式 → 处理特殊内容               ║
       ║       → 最终自检 → 反向验证                                               ║
       ╚═══════════════════════════════════════════════════════════════════════════╝ -->
  <NoteWritingChain id="note-writing" name="笔记编写思维链">

    <Step order="1" name="确定记录范围">
      <purpose>明确要记录什么，避免遗漏重要内容或记录无关内容</purpose>
      <thinking><![CDATA[
我需要记录什么内容？
- 刚刚教完的支撑知识
- 学生的验证回答（已处理：补充跳跃、纠正错误、重新组织）
- 桥接解释
- 术语约定（如果有歧义术语）

记录时机：每个支撑知识教完后立即记录，不要等到最后。
记录方式：使用 fsAppend 追加，不要覆盖。
      ]]></thinking>
      <self_check>
        <check>□ 我是否明确了要记录的内容范围？</check>
        <check>□ 我是否在支撑知识教完后立即记录？</check>
        <check>□ 我是否使用 fsAppend 而不是覆盖？</check>
      </self_check>
    </Step>

    <Step order="2" name="确定逻辑结构">
      <purpose>笔记的价值在于逻辑结构而非信息堆砌；消除并列是为了让学生复习时能理解知识点之间的关系</purpose>
      <thinking><![CDATA[
笔记的逻辑组织由教案决定。
问自己：
- 教案中定义的逻辑关系是什么？（递进/因果/对比/时序/分类）
- 如果是递进，具体是哪个维度？（PRO-1到PRO-6）
- 这个逻辑关系如何体现在笔记结构中？

关键原则：消除并列，显化逻辑关系。
      ]]></thinking>
      <self_check>
        <check>□ 我是否参考了教案中定义的逻辑关系？</check>
        <check>□ 递进关系是否体现了具体维度？</check>
        <check>□ 我是否避免了无关系的并列列举？</check>
        <check>□ 如果是分类，我是否说明了分类维度和排序依据？</check>
      </self_check>
    </Step>

    <Step order="3" name="融合信息来源">
      <purpose>融合是为了形成完整的知识点；不标注来源是为了让笔记成为统一的知识体系</purpose>
      <thinking><![CDATA[
笔记需要融合两个来源：
1. AI根据教案生成的教学内容
2. 学生验证性问题的回答

融合原则：
- AI教学内容 + 学生回答 = 一个完整知识点
- 采用更合理的逻辑组织方式
- 不标注来源（不标记"学生理解"或"教师讲解"）
      ]]></thinking>
      <self_check>
        <check>□ 我是否融合了教学内容和学生回答？</check>
        <check>□ 我是否删除了来源标注？</check>
        <check>□ 融合后的内容是否逻辑通顺？</check>
      </self_check>
    </Step>

    <Step order="4" name="应用格式规则">
      <purpose>格式规则确保笔记在Obsidian中正确渲染，缩进层级反映逻辑从属关系</purpose>
      <thinking><![CDATA[
格式规则（必须遵守）：
1. 列表标记：Tab + - + 内容（或 Tab + 1. + 内容）
2. 小标题：只用 ### 和 ####
3. 分割线：只在钩子问题之间使用
4. 缩进：表示逻辑从属（展开/支撑/细化）
5. 语义化标签：原因：、后果：、机制：、效果：、代价：
      ]]></thinking>
      <self_check>
        <check>□ 所有缩进行是否都有列表标记（- 或 1.）？</check>
        <check>□ 小标题是否只使用 ### 和 ####？</check>
        <check>□ 分割线是否只在钩子问题之间？</check>
        <check>□ 是否使用语义化标签而非元标签？</check>
      </self_check>
    </Step>

    <Step order="5" name="处理特殊内容">
      <purpose>特殊内容有特定的格式要求，正确处理可以提高笔记的可读性</purpose>
      <thinking><![CDATA[
特殊内容的处理：
1. 认知过渡：> **认知过渡**：[内容]（顶格）
2. 核心概念：**[概念名]**：[定义]（只加粗定义性核心概念）
3. 术语约定：如果有歧义术语，在首次使用时明确定义
4. 示例：简单示例紧跟概念，复杂示例单独子节
5. 重复概念：简要引用或压缩形式
      ]]></thinking>
      <self_check>
        <check>□ 认知过渡是否顶格且格式正确？</check>
        <check>□ 核心概念是否已加粗？</check>
        <check>□ 歧义术语是否在首次使用时定义？</check>
        <check>□ 是否避免了过度加粗？</check>
        <check>□ 重复出现的概念是否使用压缩形式？</check>
      </self_check>
    </Step>

    <Step order="6" name="最终自检">
      <purpose>最后一道防线，确保笔记符合所有格式和内容要求</purpose>
      <self_check>
        <check>□ 所有缩进行是否都有列表标记（- 或 1.）？</check>
        <check>□ 是否有裸露的并列列举？如有，是否说明了逻辑关系？</check>
        <check>□ 递进关系是否体现了具体维度？</check>
        <check>□ 小标题是否只使用 ### 和 ####？</check>
        <check>□ 分割线是否只在钩子问题之间？</check>
        <check>□ 核心概念是否已加粗？</check>
        <check>□ 是否删除了来源标注？</check>
      </self_check>
    </Step>

    <Step order="7" name="反向验证">
      <purpose>发现潜在问题，确保笔记对学生复习有帮助</purpose>
      <thinking><![CDATA[
问自己：
1. 学生复习这段笔记时，能否理解知识点之间的关系？
2. 递进关系的维度和排序依据是否清晰？
3. 有没有遗漏的关键信息？
4. 有没有表述不清可能导致误解的地方？
5. 格式是否会在Obsidian中正确渲染？
      ]]></thinking>
      <self_check>
        <check>□ 我是否诚实地审视了潜在问题？</check>
        <check>□ 发现的问题是否已修正？</check>
      </self_check>
    </Step>
  </NoteWritingChain>

  <!-- 更新记录 -->
  <UpdateHistory>
    <Update date="2026-01-07" version="1.0">初始版本</Update>
    <Update date="2026-01-07" version="2.0">每步增加purpose，增加反向验证步骤</Update>
    <Update date="2026-01-08" version="3.0">按逻辑层次重构，精简示例，突出核心流程</Update>
    <Update date="2026-01-08" version="4.0">
      教案编写链增加：识别前置知识、定义术语边界、递进维度选择、L4应用性问题
      笔记编写链增加：术语约定处理、递进维度体现
    </Update>
  </UpdateHistory>

</ThinkingChains>
